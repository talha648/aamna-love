<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Ludo â€” T ðŸ’– A Edition (with bots, sounds, save)</title>
<style>
  :root{
    --size:760px;
    --cell:calc(var(--size)/15);
    --panel-bg: rgba(255,255,255,0.06);
  }
  html,body{height:100%;margin:0;font-family:Inter,Arial,system-ui;background:
    linear-gradient(-45deg,#ff9a9e,#ffd1dc,#ffe6f0,#fceef3);background-size:400% 400%;
    animation:grad 12s ease infinite;color:#061022}
  @keyframes grad{0%{background-position:0 50%}50%{background-position:100% 50%}100%{background-position:0 50%}}
  .wrap{min-height:100vh;display:flex;align-items:center;justify-content:center;padding:20px;box-sizing:border-box;gap:20px}
  .board-wrap{width:var(--size);height:var(--size);position:relative;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,0.25);overflow:hidden;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01))}
  canvas#board{width:100%;height:100%;display:block}
  .tokens-layer{position:absolute;inset:6px;pointer-events:none}
  .panel{width:360px;padding:16px;border-radius:12px;background:var(--panel-bg);box-shadow:0 12px 30px rgba(2,6,23,0.35)}
  .panel h2{margin:0 0 10px}
  .row{display:flex;gap:8px;align-items:center}
  .btn{padding:10px 12px;border-radius:8px;border:none;cursor:pointer;background:#2b2f45;color:white}
  .primary{background:linear-gradient(180deg,#ff6b81,#ff3b57);box-shadow:0 6px 18px rgba(255,80,107,0.16)}
  select,input[type="number"]{padding:8px;border-radius:6px;border:1px solid rgba(0,0,0,0.08)}
  .message{margin-top:10px;padding:8px;border-radius:8px;background:rgba(255,255,255,0.02);min-height:44px}
  .players{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:8px}
  .p-card{flex:1;padding:8px;border-radius:8px;background:rgba(255,255,255,0.03);display:flex;align-items:center;gap:8px}
  .dot{width:14px;height:14px;border-radius:50%}
  .dot.red{background:#ff506b}.dot.blue{background:#2a84ff}.dot.green{background:#22b85a}.dot.yellow{background:#ff9b00}
  .controls{display:flex;gap:8px;margin-top:8px}
  .small{font-size:13px;color:#061022;opacity:.8}
  .floating-love{position:fixed;font-size:22px;pointer-events:none;z-index:60;text-shadow:0 6px 12px rgba(0,0,0,0.18)}
  .winner-overlay{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.5);z-index:70;display:none}
  .winner-box{background:white;padding:24px;border-radius:12px;color:#061022;text-align:center}
  @media(max-width:980px){.wrap{flex-direction:column}.panel{width:100%;max-width:420px}}
</style>
</head>
<body>
<div class="wrap">
  <div class="board-wrap" id="boardWrap">
    <canvas id="board" width="760" height="760" aria-label="Ludo board"></canvas>
    <div class="tokens-layer" id="tokensLayer"></div>
  </div>

  <div class="panel">
    <h2>T ðŸ’– A â€” Ludo (bots, sounds, save)</h2>

    <div class="players" id="playersUI"></div>

    <div class="row" style="margin-bottom:8px">
      <div style="flex:1">
        <div class="small">Bot difficulty</div>
        <select id="botDifficulty"><option value="easy">Easy</option><option value="medium" selected>Medium</option></select>
      </div>
      <div>
        <div class="small">Bots</div>
        <input id="botCount" type="number" min="0" max="3" value="0" style="width:64px">
      </div>
    </div>

    <div class="controls">
      <button id="rollBtn" class="btn primary">Roll</button>
      <button id="resetBtn" class="btn">Reset</button>
      <button id="saveBtn" class="btn">Save</button>
    </div>

    <div style="display:flex;gap:8px;margin-top:8px;align-items:center">
      <label style="display:flex;gap:8px;align-items:center"><input id="soundToggle" type="checkbox" checked> Sound</label>
      <label style="display:flex;gap:8px;align-items:center"><input id="autoSave" type="checkbox" checked> Auto-save</label>
      <button id="clearSave" class="btn" style="margin-left:auto;background:#ffdede;color:#061022">Clear Save</button>
    </div>

    <div style="margin-top:10px" class="small">Dice: <span id="lastRoll">-</span></div>
    <div class="message" id="message">Click Roll to start. You need a 6 to exit base.</div>

    <div style="margin-top:10px" class="small">Controls: Click a token to select it when prompted. Bots play automatically.</div>
    <div style="margin-top:12px;display:flex;gap:8px">
      <button id="exportBtn" class="btn">Export Save</button>
      <button id="importBtn" class="btn">Import Save</button>
    </div>
  </div>
</div>

<div class="winner-overlay" id="winnerOverlay">
  <div class="winner-box">
    <h2 id="winnerText">Winner!</h2>
    <div style="margin-top:12px"><button id="playAgain" class="btn primary">Play Again</button></div>
  </div>
</div>

<script>
/* ====== Ludo TðŸ’–A Edition (single-file) ======
Features:
- Realistic 52-step path mapped to 15x15 board
- 2-4 players local, bots (easy/medium)
- Dice animations + WebAudio synth for dice/capture/win
- localStorage save/restore, export/import
- Simple UI and token click selection
------------------------------------------------
State & data structures are saved/restored from localStorage key: 'tla_ludo_save'
------------------------------------------------
*/

const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d', {alpha:false});
const W = canvas.width, H = canvas.height;
const tokensLayer = document.getElementById('tokensLayer');
const playersUI = document.getElementById('playersUI');
const rollBtn = document.getElementById('rollBtn');
const resetBtn = document.getElementById('resetBtn');
const saveBtn = document.getElementById('saveBtn');
const clearSaveBtn = document.getElementById('clearSave');
const soundToggle = document.getElementById('soundToggle');
const autoSaveToggle = document.getElementById('autoSave');
const botCountInput = document.getElementById('botCount');
const botDifficultySelect = document.getElementById('botDifficulty');
const messageEl = document.getElementById('message');
const lastRollEl = document.getElementById('lastRoll');
const winnerOverlay = document.getElementById('winnerOverlay');
const winnerText = document.getElementById('winnerText');
const playAgainBtn = document.getElementById('playAgain');
const exportBtn = document.getElementById('exportBtn');
const importBtn = document.getElementById('importBtn');

const STORAGE_KEY = 'tla_ludo_save_v1';

// board grid config
const GRID = 15;
const CELL = W / GRID;

// colors
const COLORS = { red:'#ff506b', blue:'#2a84ff', green:'#22b85a', yellow:'#ff9b00' };
const playersOrder = ['red','blue','green','yellow'];

// standard Ludo mapping to 15x15 coordinates (row, col) for 52 steps
// This mapping is constructed to reflect a classic Ludo board layout on 15x15.
const PATH = [
  [6,1],[6,2],[6,3],[6,4],[6,5],[5,6],[4,6],[3,6],[2,6],[1,6],[0,6],[0,7],
  [0,8],[1,8],[2,8],[3,8],[4,8],[5,8],[6,9],[6,10],[6,11],[6,12],[6,13],[6,14],
  [7,14],[8,14],[8,13],[8,12],[8,11],[8,10],[8,9],[8,8],[9,8],[10,8],[11,8],[12,8],
  [13,8],[14,8],[14,7],[14,6],[13,6],[12,6],[11,6],[10,6],[9,6],[8,5],[8,4],[8,3],
  [8,2],[8,1
];
// The PATH array should have 52 entries; if it doesn't due to copy issues, fallback generation will be used.
if(PATH.length !== 52){
  // fallback: generate outer rectangle loop (works for gameplay)
  PATH.length = 0;
  for(let c=1;c<=13 && PATH.length<52;c++) PATH.push([1,c]);
  for(let r=1;r<=13 && PATH.length<52;r++) PATH.push([r,13]);
  for(let c=13;c>=1 && PATH.length<52;c--) PATH.push([13,c]);
  for(let r=13;r>=1 && PATH.length<52;r--) PATH.push([r,1]);
}

// starting index (entry onto board) for each player (red starts at PATH index 0, blue 13, green 26, yellow 39)
const playerStartIndex = { red:0, blue:13, green:26, yellow:39 };

// home column mapping: for each player, their home entry is the square at startIndex - 1 (mod 52)
function homeEntryIndexForPlayerIdx(pi){
  const name = playersOrder[pi];
  const start = playerStartIndex[name];
  return (start + 51) % PATH.length; // square before start
}

// safe squares set (commonly the 4 starting squares and corner entries)
const safeIndices = new Set([
  playerStartIndex.red,
  playerStartIndex.blue,
  playerStartIndex.green,
  playerStartIndex.yellow,
  (playerStartIndex.red+13)%52,
  (playerStartIndex.blue+13)%52,
  (playerStartIndex.green+13)%52,
  (playerStartIndex.yellow+13)%52
]);

// game state
let state = {
  playerCount:4,
  bots:0,
  botDifficulty:'medium',
  tokens: null, // tokens[p][t] = -1 (base) | 0..51 path | 100+player*6+step home (step 0..5)
  finished: [0,0,0,0],
  currentPlayerIndex: 0, // index into activePlayers array
  activePlayers: [0,1,2,3],
  lastRoll: null,
  message: 'Click Roll to start. Need a 6 to exit base.'
};

// audio (WebAudio)
let audioCtx = null;
function ensureAudio(){
  if(!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
}

// tiny synthesizer helper
function playTone(freq, duration=0.18, type='sine', gain=0.12){
  if(!soundToggle.checked) return;
  ensureAudio();
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type; o.frequency.value = freq;
  g.gain.setValueAtTime(gain, audioCtx.currentTime);
  o.connect(g); g.connect(audioCtx.destination);
  o.start();
  g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + duration);
  setTimeout(()=>{ o.stop(); }, duration*1000 + 30);
}
function playDiceSound(){
  // quick ascending blips
  playTone(450,0.06,'sine',0.06);
  setTimeout(()=>playTone(560,0.06,'sine',0.055),70);
  setTimeout(()=>playTone(660,0.06,'sine',0.05),140);
}
function playCaptureSound(){
  playTone(220,0.14,'sawtooth',0.12);
  setTimeout(()=>playTone(120,0.12,'sine',0.09),120);
}
function playWinSound(){
  playTone(880,0.18,'sine',0.12);
  setTimeout(()=>playTone(660,0.18,'sine',0.12),220);
  setTimeout(()=>playTone(980,0.28,'sine',0.14),420);
}

// utilities for home indexing
function toHomeIndex(pIdx, step){ return 100 + pIdx*6 + step; }
function isHomeIndex(v){ return v >= 100; }
function homeStepFromIndex(v){ return v - 100 - Math.floor((v-100)/6)*6; }

// init or restore game
function freshState(){
  const tokens = [];
  for(let p=0;p<4;p++) tokens[p] = [-1,-1,-1,-1];
  return { playerCount:4, bots:0, botDifficulty:'medium', tokens, finished:[0,0,0,0], currentPlayerIndex:0, activePlayers:[0,1,2,3], lastRoll:null, message:'Click Roll to start. Need a 6 to exit base.' };
}
function loadState(){
  const raw = localStorage.getItem(STORAGE_KEY);
  if(raw){
    try{
      const s = JSON.parse(raw);
      // basic validation
      if(s && s.tokens) { state = s; updateUIFromState(); return true; }
    }catch(e){}
  }
  state = freshState();
  return false;
}
function saveState(){
  if(!autoSaveToggle.checked) return;
  localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
}
function clearSave(){
  localStorage.removeItem(STORAGE_KEY);
  state = freshState();
  updateUIFromState();
  render();
  setMessage('Save cleared. New game ready.');
}

/* ---------- Drawing board ---------- */
function drawBoard(){
  // clear
  ctx.fillStyle = '#fdf7fb'; // subtle base
  ctx.fillRect(0,0,W,H);

  // draw grid background slightly
  ctx.fillStyle = 'rgba(255,255,255,0.02)';
  ctx.fillRect(4,4,W-8,H-8);

  // draw the four home squares (6x6 cells)
  drawHomeBlock(0,0,'red');
  drawHomeBlock(0,9,'blue');
  drawHomeBlock(9,9,'yellow');
  drawHomeBlock(9,0,'green');

  // draw path squares (use PATH mapping)
  for(let i=0;i<PATH.length;i++){
    const [r,c] = PATH[i];
    const {x,y} = gridToPixel(r,c);
    ctx.fillStyle = safeIndices.has(i) ? 'rgba(255,255,255,0.06)' : 'rgba(0,0,0,0.02)';
    roundRect(ctx,x+2,y+2,CELL-4,CELL-4,6,true,false);
    // small marker
    ctx.fillStyle = 'rgba(0,0,0,0.12)';
    ctx.font = `${Math.max(10, CELL/6)}px Arial`;
    // (optional) show index for debug: comment out to remove indices
    // ctx.fillText(i, x+6, y+14);
  }

  // draw center home lanes (4 colored triangles plus central area)
  drawHomeLane(0,'red');
  drawHomeLane(1,'blue');
  drawHomeLane(2,'yellow');
  drawHomeLane(3,'green');

  // center circle / label
  const centerRect = {x: gridToPixel(5,5).x + CELL*0, y: gridToPixel(5,5).y, w: CELL*4, h: CELL*4};
  ctx.fillStyle = 'rgba(255,255,255,0.02)';
  roundRect(ctx, centerRect.x, centerRect.y, centerRect.w, centerRect.h, 8, true, false)
  ctx.fillStyle = '#061022';
  ctx.font = '18px Verdana';
  ctx.textAlign = 'center';
  ctx.fillText('T â¤ï¸ A', centerRect.x + centerRect.w/2, centerRect.y + centerRect.h/2 - 4);
  ctx.font = '12px Arial';
  ctx.fillText('Playful Ludo â€” local multiplayer', centerRect.x + centerRect.w/2, centerRect.y + centerRect.h/2 + 16);
}

/* helpers for drawing */
function drawHomeBlock(r0,c0,color){
  const {x,y} = gridToPixel(r0,c0);
  ctx.fillStyle = colorBlockFill(color);
  roundRect(ctx,x+2,y+2,CELL*6-4,CELL*6-4,10,true,false);
  // small decoration: 4 circles where tokens will sit
  const tokenGap = CELL*1.8;
  const startX = x + CELL + 10;
  const startY = y + CELL + 8;
  for(let i=0;i<2;i++){
    for(let j=0;j<2;j++){
      const cx = startX + j*tokenGap;
      const cy = startY + i*tokenGap;
      ctx.beginPath(); ctx.fillStyle = '#fff'; ctx.globalAlpha = 0.06; ctx.arc(cx,cy,CELL*0.4,0,Math.PI*2); ctx.fill(); ctx.globalAlpha = 1;
    }
  }
}
function drawHomeLane(pIdx,color){
  // home lanes: 6 cells from entry to center
  const entryIndex = playerStartIndex[playersOrder[pIdx]];
  // compute coordinates for the 6 home cells (pre-determined per player)
  const laneCoords = homeLaneCoordsForPlayer(pIdx);
  laneCoords.forEach((rc,i)=>{
    const {x,y} = gridToPixel(rc[0], rc[1]);
    ctx.fillStyle = colorBlockFill(color);
    roundRect(ctx, x+6, y+6, CELL-12, CELL-12, 6, true, false);
  });
}
function colorBlockFill(name){
  if(name==='red') return 'linearGradient' // placeholder not used
  return COLORS[name] || '#ccc';
}
function roundRect(ctx,x,y,w,h,r,fill,stroke){
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.closePath();
  if(fill) ctx.fill();
  if(stroke) ctx.stroke();
}
function gridToPixel(r,c){ return { x: c * CELL, y: r * CELL }; }

// home lane coordinates (6 cells including final) for players in 15x15 layout
function homeLaneCoordsForPlayer(pi){
  // Each player has a sequence of 6 cells approaching center; coords chosen for classic layout
  if(pi===0){ // red (top-left) go down-right towards center
    return [[5,1],[5,2],[5,3],[5,4],[5,5],[5,6]];
  } else if(pi===1){ // blue (top-right) go left-down
    return [[1,9],[2,9],[3,9],[4,9],[5,9],[6,9]];
  } else if(pi===2){ // yellow (bottom-right) go up-left
    return [[9,13],[9,12],[9,11],[9,10],[9,9],[9,8]];
  } else { // green (bottom-left) go right-up
    return [[13,5],[12,5],[11,5],[10,5],[9,5],[8,5]];
  }
}

/* ---------- Token rendering & positions ---------- */
function clearTokensLayer(){ tokensLayer.innerHTML = ''; }
function renderTokens(){
  clearTokensLayer();
  // iterate players (activePlayers)
  const active = state.activePlayers;
  const gridRect = canvas.getBoundingClientRect();
  active.forEach((playerIdx, pIdx)=>{
    for(let t=0;t<4;t++){
      const pos = state.tokens[playerIdx][t];
      const el = document.createElement('div');
      el.className = 'token';
      el.style.position = 'absolute';
      el.style.width = (CELL*0.75) + 'px';
      el.style.height = (CELL*0.75) + 'px';
      el.style.borderRadius = '50%';
      el.style.display = 'flex';
      el.style.alignItems = 'center';
      el.style.justifyContent = 'center';
      el.style.color = '#fff';
      el.style.fontWeight = '700';
      el.style.boxShadow = '0 6px 18px rgba(0,0,0,0.28)';
      el.style.cursor = 'pointer';
      el.dataset.player = playerIdx; el.dataset.token = t;
      el.innerText = (t+1);
      // style by color
      const col = COLORS[playersOrder[playerIdx]] || '#999';
      el.style.background = `linear-gradient(180deg, ${col}, ${shadeColor(col,-12)})`;
      // pointer events to allow player clicking
      el.style.pointerEvents = 'auto';

      // compute pixel position
      let px=0, py=0;
      if(pos === -1){
        // base: four spots inside home block (use home block coordinates)
        const baseCell = homeBaseCellForPlayer(playerIdx);
        const {x,y} = gridToPixel(baseCell[0], baseCell[1]);
        // offsets for 4 tokens
        const offsets = [[6,6],[CELL*0.9,6],[6,CELL*0.9],[CELL*0.9,CELL*0.9]];
        const off = offsets[t];
        px = x + off[0]; py = y + off[1];
      } else if(isHomeIndex(pos)){
        // place within home lane cell at step position
        const playerIdxFromPos = Math.floor((pos-100)/6);
        const step = (pos - 100) % 6;
        const lane = homeLaneCoordsForPlayer(playerIdxFromPos);
        const cell = lane[step];
        const {x,y} = gridToPixel(cell[0], cell[1]);
        px = x + CELL*0.12; py = y + CELL*0.12;
      } else {
        // on path
        const coord = PATH[pos % PATH.length];
        const {x,y} = gridToPixel(coord[0], coord[1]);
        // cluster multiple tokens on same cell slightly
        const sameCountAndIndex = countTokensOnPosition(pos, playerIdx, t);
        const spacing = 8;
        px = x + 6 + ( (sameCountAndIndex.index % 2) * spacing );
        py = y + 6 + ( Math.floor(sameCountAndIndex.index/2) * spacing );
      }

      // assign style left/top relative to canvas
      el.style.left = px + 'px';
      el.style.top = py + 'px';
      // click handler (player selection)
      el.addEventListener('click', onTokenClick);
      tokensLayer.appendChild(el);
    }
  });
  updatePlayersUI();
}

function homeBaseCellForPlayer(playerIdx){
  // pick a cell inside 6x6 home block used for base positions
  if(playerIdx===0) return [1,1]; // top-left zone inside block
  if(playerIdx===1) return [1,11]; // top-right
  if(playerIdx===2) return [11,11]; // bottom-right
  return [11,1]; // bottom-left
}

// count tokens on same path index (for clustering)
function countTokensOnPosition(pos, ownerPlayerIdx, tokenIndex){
  let index = 0;
  let total = 0;
  // iterate all active tokens and find those with same pos
  for(let p=0;p<4;p++){
    for(let t=0;t<4;t++){
      if(state.tokens[p][t] === pos){
        if(p===ownerPlayerIdx && t===tokenIndex) index = total;
        total++;
      }
    }
  }
  return { total, index };
}
function shadeColor(hex, percent) {
  // hex -> shade darker/lighter
  hex = hex.replace('#','');
  const num = parseInt(hex,16);
  const r = Math.min(255, Math.max(0, (num >> 16) + percent));
  const g = Math.min(255, Math.max(0, (num >> 8 & 0x00FF) + percent));
  const b = Math.min(255, Math.max(0, (num & 0x0000FF) + percent));
  return '#' + ( (1<<24) + (r<<16) + (g<<8) + b ).toString(16).slice(1);
}

/* ---------- Game logic: moves, captures, turns ---------- */
function possibleMovesForPlayer(playerIdx, roll){
  const moves = [];
  for(let t=0;t<4;t++){
    const pos = state.tokens[playerIdx][t];
    if(pos === -1){
      if(roll === 6) moves.push(t);
    } else if(isHomeIndex(pos)){
      const playerHomeBase = 100 + playerIdx*6;
      const step = pos - playerHomeBase;
      if(step < 5) moves.push(t);
    } else {
      // normal path move; allow movement always (blocked logic optional)
      moves.push(t);
    }
  }
  return moves;
}

function stepsToHomeEntry(playerIdx, pos){
  // distance (number of path steps) from pos to player's home entry square (the square right before home lane)
  const entryIndex = homeEntryIndexForPlayer(playerIdx);
  const pathLen = PATH.length;
  let dist = (entryIndex - pos + pathLen) % pathLen;
  if(dist === 0) dist = pathLen;
  return dist;
}

function doMove(playerIdx, tokenIdx, roll){
  clearSelection();
  const pos = state.tokens[playerIdx][tokenIdx];
  if(pos === -1 && roll === 6){
    // enter onto start square
    const start = playerStartIndex[playersOrder[playerIdx]];
    state.tokens[playerIdx][tokenIdx] = start;
    playCaptureSoundIfEnabled(true); // small sound (optional)
    setMessage(`${playersOrder[playerIdx]} moved token ${tokenIdx+1} out of base.`);
    resolveCaptures(playerIdx, start);
    renderTokens(); afterMove(playerIdx, roll); return;
  }
  if(isHomeIndex(pos)){
    const homeBase = 100 + playerIdx*6;
    const step = pos - homeBase;
    const newStep = step + 1;
    if(newStep <= 5){
      state.tokens[playerIdx][tokenIdx] = homeBase + newStep;
      if(newStep === 5){ state.finished[playerIdx]++; if(state.finished[playerIdx] >= 4){ onWin(playerIdx); } }
      setMessage(`${playersOrder[playerIdx]} moved token ${tokenIdx+1} inside home.`);
    } else {
      setMessage('Cannot move inside home.');
    }
    renderTokens(); afterMove(playerIdx, roll); return;
  }
  // normal path move
  const pathLen = PATH.length;
  const startIdx = playerStartIndex[playersOrder[playerIdx]];
  const stepsToStart = (startIdx - pos + pathLen) % pathLen;
  if(roll > stepsToStart){
    // enters home column
    const overflow = roll - stepsToStart - 1; // 0-based
    const homeBase = 100 + playerIdx*6;
    const homeStep = Math.min(overflow,5);
    state.tokens[playerIdx][tokenIdx] = homeBase + homeStep;
    if(homeStep === 5){ state.finished[playerIdx]++; if(state.finished[playerIdx] >= 4){ onWin(playerIdx); } }
    setMessage(`${playersOrder[playerIdx]} token ${tokenIdx+1} enters home column!`);
    renderTokens(); afterMove(playerIdx, roll); return;
  } else {
    const newPos = (pos + roll) % pathLen;
    state.tokens[playerIdx][tokenIdx] = newPos;
    setMessage(`${playersOrder[playerIdx]} token ${tokenIdx+1} moved ${roll} steps to ${newPos}.`);
    resolveCaptures(playerIdx, newPos);
    renderTokens(); afterMove(playerIdx, roll); return;
  }
}

function resolveCaptures(playerIdx, newPos){
  if(isHomeIndex(newPos)) return;
  if(safeIndices.has(newPos)) return;
  // find opponents on same newPos and send them to base
  for(let p=0;p<4;p++){
    if(p === playerIdx) continue;
    for(let t=0;t<4;t++){
      if(state.tokens[p][t] === newPos){
        state.tokens[p][t] = -1;
        setMessage(`${playersOrder[playerIdx]} captured ${playersOrder[p]}'s token!`);
        if(soundToggle.checked) playCaptureSound();
      }
    }
  }
}

function afterMove(playerIdx, roll){
  // set last roll, save, handle extra roll on 6
  state.lastRoll = roll;
  lastRollEl.innerText = roll;
  saveStateIfNeeded();
  if(roll === 6){
    setMessage(`${playersOrder[playerIdx]} rolled a 6 â€” go again!`);
    // same player's turn â€” if it's a bot, schedule another bot action
    scheduleBotIfNeeded();
  } else {
    // next player
    state.currentPlayerIndex = (state.currentPlayerIndex + 1) % state.activePlayers.length;
    setTimeout(()=>{ setMessage(`${playersOrder[state.activePlayers[state.currentPlayerIndex]]}'s turn.`); scheduleBotIfNeeded(); }, 250);
  }
}

// check winning
function onWin(playerIdx){
  winnerText.innerText = `${playersOrder[playerIdx].toUpperCase()} Wins! â¤ï¸`;
  winnerOverlay.style.display = 'flex';
  if(soundToggle.checked) playWinSound();
}

// selection & user click
let awaitingSelectionFor = null; // {playerIdx, validMoves: [t,...], roll}
function highlightMovable(playerIdx, moves){
  awaitingSelectionFor = { playerIdx, moves, roll: state.lastRoll };
  setMessage(`${playersOrder[playerIdx]}: choose a token (or bot will pick).`);
  // visually highlight by adding a glow style to token DOM nodes (tokens are DOM elems in tokensLayer)
  // tokens are automatically clickable and trigger onTokenClick.
}
function clearSelection(){
  awaitingSelectionFor = null;
  // remove any visual highlights if added (we didn't add persistent ones).
}
function onTokenClick(e){
  const el = e.currentTarget;
  const p = parseInt(el.dataset.player), t = parseInt(el.dataset.token);
  if(!awaitingSelectionFor) return;
  if(p !== awaitingSelectionFor.playerIdx) return;
  if(!awaitingSelectionFor.moves.includes(t)) {
    setMessage('That token cannot move for this roll.');
    return;
  }
  doMove(p,t, awaitingSelectionFor.roll);
}

// capture sound helper small
function playCaptureSoundIfEnabled(small=false){
  if(!soundToggle.checked) return;
  if(small) playToneOnce(300, 0.06);
  else playCaptureSound();
}
function playToneOnce(freq,dur){ ensureAudio(); playTone(freq,dur); }

// Dice roll UI flow
let diceAnimating = false;
function rollDiceAction(){
  if(diceAnimating) return;
  const currentPlayer = state.activePlayers[state.currentPlayerIndex];
  // if it's a bot and bots exist and it's human click, still allow - but bots will handle automatically
  diceAnimating = true;
  // simple animation: show random numbers quickly
  let steps = 12, t=0;
  const iv = setInterval(()=>{
    const tmp = 1 + Math.floor(Math.random()*6);
    lastRollEl.innerText = tmp;
    t++;
    if(t>=steps){
      clearInterval(iv);
      const result = 1 + Math.floor(Math.random()*6);
      lastRollEl.innerText = result;
      state.lastRoll = result;
      if(soundToggle.checked) playDiceSound();
      diceAnimating = false;
      // handle roll for current player
      const moves = possibleMovesForPlayer(currentPlayer, result);
      if(moves.length === 0){
        setMessage(`${playersOrder[currentPlayer]} : No moves. Turn passes.`);
        if(result !== 6){
          state.currentPlayerIndex = (state.currentPlayerIndex + 1) % state.activePlayers.length;
          scheduleBotIfNeeded();
        } else {
          setMessage(`${playersOrder[currentPlayer]} rolled a 6 but no moves.`);
          scheduleBotIfNeeded();
        }
        saveStateIfNeeded();
      } else if(moves.length === 1 && isBotTurn()){
        // if bot and single move, auto move
        setTimeout(()=>{ doMove(currentPlayer, moves[0], result); }, 400);
      } else if(isBotTurn()){
        // bot to choose according to difficulty
        setTimeout(()=>{ botChooseAndPlay(currentPlayer, result); }, 350 + Math.random()*600);
      } else {
        // human: highlight moves for selection
        highlightMovable(currentPlayer, moves);
      }
      saveStateIfNeeded();
    }
  }, 60);
}

/* ---------- Bot logic (easy & medium) ---------- */
function isBotTurn(){
  const bots = state.bots;
  if(bots <= 0) return false;
  // determine if current player is one of the last N players assigned as bots (we'll assign bots to last N players in active players order)
  const idx = state.activePlayers[state.currentPlayerIndex];
  // Map first players to humans, last 'bots' players to AI
  // Simpler: if idx < (state.playerCount - bots) => human else bot
  const humanCount = state.playerCount - state.bots;
  const isBot = (state.activePlayers.indexOf(idx) >= humanCount);
  return isBot;
}

function botChooseAndPlay(playerIdx, roll){
  const difficulty = state.botDifficulty || 'medium';
  const moves = possibleMovesForPlayer(playerIdx, roll);
  if(moves.length === 0){
    // pass
    if(roll !== 6){
      state.currentPlayerIndex = (state.currentPlayerIndex + 1) % state.activePlayers.length;
    }
    saveStateIfNeeded();
    scheduleBotIfNeeded();
    return;
  }
  let choice = moves[Math.floor(Math.random()*moves.length)];
  if(difficulty === 'easy'){
    // random (already default)
  } else {
    // medium heuristic:
    // 1) capture moves
    // 2) move into home if possible
    // 3) advance token closest to finish (max progress)
    // otherwise random
    // compute capture candidates
    const captureMoves = [];
    const enterHomeMoves = [];
    let bestAdvance = null; let bestAdvanceScore = -Infinity;
    for(const t of moves){
      const pos = state.tokens[playerIdx][t];
      if(pos === -1 && roll === 6){
        // entering onto start -> consider if immediately captures
        const dest = playerStartIndex[playersOrder[playerIdx]];
        if(willCaptureAt(playerIdx, dest)) captureMoves.push(t);
        else enterHomeMoves.push(t);
      } else if(isHomeIndex(pos)){
        // ignore
      } else {
        const pathLen = PATH.length;
        const startIdx = playerStartIndex[playersOrder[playerIdx]];
        const stepsToStart = (startIdx - pos + pathLen) % pathLen;
        if(roll > stepsToStart){
          enterHomeMoves.push(t);
        } else {
          const dest = (pos + roll) % pathLen;
          if(willCaptureAt(playerIdx, dest)) captureMoves.push(t);
          // score by proximity to completing loop (larger total progress preferred)
          const progress = (pos - startIdx + pathLen) % pathLen;
          const score = progress + roll;
          if(score > bestAdvanceScore){ bestAdvanceScore = score; bestAdvance = t; }
        }
      }
    }
    if(captureMoves.length) choice = captureMoves[0];
    else if(enterHomeMoves.length) choice = enterHomeMoves[0];
    else if(bestAdvance !== null) choice = bestAdvance;
    else choice = moves[Math.floor(Math.random()*moves.length)];
  }
  // perform move after small delay to mimic thinking
  setTimeout(()=>{ doMove(playerIdx, choice, roll); }, 300 + Math.random()*500);
}
function willCaptureAt(playerIdx, dest){
  if(isHomeIndex(dest)) return false;
  if(safeIndices.has(dest)) return false;
  for(let p=0;p<4;p++){
    if(p===playerIdx) continue;
    for(let t=0;t<4;t++) if(state.tokens[p][t] === dest) return true;
  }
  return false;
}

/* schedule bot on next turn if needed */
function scheduleBotIfNeeded(){
  // if it's bot's turn, trigger automatic roll after delay
  const currentPlayer = state.activePlayers[state.currentPlayerIndex];
  const humanCount = state.playerCount - state.bots;
  const indexInActive = state.activePlayers.indexOf(currentPlayer);
  const isBot = (indexInActive >= humanCount);
  if(isBot){
    // bot will roll automatically after small delay
    setTimeout(()=>{ rollDiceAction(); }, 600 + Math.random()*800);
  }
}

/* ---------- UI & events ---------- */
function updatePlayersUI(){
  playersUI.innerHTML = '';
  for(let i=0;i<state.playerCount;i++){
    const card = document.createElement('div'); card.className='p-card';
    const dot = document.createElement('div'); dot.className = 'dot ' + playersOrder[i];
    const label = document.createElement('div'); label.innerHTML = `<strong>${playersOrder[i].toUpperCase()}</strong><div style="font-size:12px;color:#061022;opacity:.75">Finished: ${state.finished[i]}</div>`;
    card.appendChild(dot); card.appendChild(label);
    playersUI.appendChild(card);
  }
}

function updateUIFromState(){
  // bot controls, difficulty, player count
  botCountInput.value = state.bots;
  botDifficultySelect.value = state.botDifficulty || 'medium';
  lastRollEl.innerText = state.lastRoll || '-';
  setMessage(state.message || 'Ready');
  renderTokens();
}

function setMessage(txt){
  state.message = txt;
  messageEl.innerText = txt;
  saveStateIfNeeded();
}

// event handlers
rollBtn.addEventListener('click', ()=> {
  if(isBotTurn()){
    // allow manual roll even if bot; but preferred is automatic
  }
  rollDiceAction();
});
resetBtn.addEventListener('click', ()=> {
  if(!confirm('Reset game?')) return;
  state = freshState();
  saveStateIfNeeded();
  renderTokens();
  setMessage('New game. Click Roll.');
});
saveBtn.addEventListener('click', ()=> {
  localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
  setMessage('Game saved.');
});
clearSaveBtn.addEventListener('click', ()=> {
  if(!confirm('Clear saved game?')) return;
  clearSave();
});
botCountInput.addEventListener('change', ()=> {
  const v = Math.max(0, Math.min(3, parseInt(botCountInput.value) || 0));
  state.bots = v;
  // ensure bots do not exceed players-1
  if(state.bots >= state.playerCount) state.bots = state.playerCount - 1;
  botCountInput.value = state.bots;
  saveStateIfNeeded();
  renderTokens();
});
botDifficultySelect.addEventListener('change', ()=> { state.botDifficulty = botDifficultySelect.value; saveStateIfNeeded(); });
soundToggle.addEventListener('change', ()=> { if(soundToggle.checked) { ensureAudio(); } });
autoSaveToggle.addEventListener('change', ()=> { saveStateIfNeeded(); });
playAgainBtn.addEventListener('click', ()=> { winnerOverlay.style.display='none'; state = freshState(); saveStateIfNeeded(); renderTokens(); setMessage('New game. Click Roll.'); });

// export/import save
exportBtn.addEventListener('click', ()=> {
  const data = JSON.stringify(state, null, 2);
  const blob = new Blob([data], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'ludo-save.json'; a.click(); URL.revokeObjectURL(url);
});
importBtn.addEventListener('click', ()=> {
  const inp = document.createElement('input'); inp.type = 'file'; inp.accept = 'application/json';
  inp.onchange = (e)=> {
    const file = e.target.files[0];
    if(!file) return;
    const reader = new FileReader();
    reader.onload = (ev)=> {
      try{
        const obj = JSON.parse(ev.target.result);
        if(obj && obj.tokens) { state = obj; saveStateIfNeeded(); updateUIFromState(); renderTokens(); setMessage('Save imported.'); }
        else alert('Invalid save file.');
      }catch(err){ alert('Invalid JSON file.'); }
    }
    reader.readAsText(file);
  };
  inp.click();
});

/* ---------- Save helpers ---------- */
function saveStateIfNeeded(){ if(autoSaveToggle.checked) localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); }
function initFromStorage(){
  const ok = loadState();
  if(!ok){
    state = freshState();
    saveStateIfNeeded();
  }
  // apply UI values
  botCountInput.value = state.bots;
  botDifficultySelect.value = state.botDifficulty;
  updateUIFromState();
}

/* ---------- Floating love emojis (decorative) ---------- */
const LOVE = ["ðŸ’–","â¤ï¸","ðŸ’‹","ðŸ’","ðŸ˜˜","ðŸ’•","ðŸ˜","ðŸŒ¹","ðŸ’ž","ðŸ’—"];
function spawnLove(xPercent){
  const el = document.createElement('div');
  el.className = 'floating-love';
  el.innerText = LOVE[Math.floor(Math.random()*LOVE.length)];
  el.style.left = (xPercent || (Math.random()*80+10)) + 'vw';
  const size = 14 + Math.random()*24; el.style.fontSize = size + 'px';
  el.style.top = '110vh';
  document.body.appendChild(el);
  const dur = 6 + Math.random()*5; el.style.transition = `transform ${dur}s linear, top ${dur}s linear, opacity ${dur}s linear`;
  setTimeout(()=>{ el.style.transform = `translateY(-140vh) rotate(${Math.random()*360}deg)`; el.style.opacity = '0.9'; }, 30);
  setTimeout(()=> el.remove(), (dur+0.3)*1000);
}
let loveInterval = null;
function startLoveStream(){ for(let i=0;i<6;i++){ setTimeout(()=>spawnLove(), i*120); } loveInterval = setInterval(()=>spawnLove(), 420); }
function stopLoveStream(){ if(loveInterval) clearInterval(loveInterval); }

/* ---------- Boot & render ---------- */
function render(){
  drawBoard();
  renderTokens();
}
initFromStorage();
render();
startLoveStream();
updatePlayersUI();
scheduleBotIfNeeded();

/* if saved game exists, restore UI values and schedule bots */
if(state.lastRoll) lastRollEl.innerText = state.lastRoll;
setMessage(state.message || 'Ready');

// helper to ensure audio context resumed on user gesture (some browsers block autoplay)
document.addEventListener('click', ()=> { if(audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); }, {once:true});

</script>
</body>
</html>
